#' @title Filter Pairwise Alignment File produced by Minimap2
#'
#' @description
#' Filter out secundary alignments and non-TARGET/HOST chimeric.
#' In PAF format each line represents the mapping information of a read substring.
#' While filtering an extra field called "ligation" is created depicting the presence/absence of mapping onto the TARGET using the following code: 0 (mapping HOST) and 1 (mapping TARGET). This field is collapsed by read and only reads harboring one of the following substrings combinations are selected: 01, 10, 101, 1001.
#'
#' @param minimap2PAF tibble. Pairwise Alignment file generated by minimap2 and loaded with \code{readPairwiseAlignmentFile}
#' @param targetName character. Name of the TARGET chromosome
#'
#' @return PCIP filtered and formated PAF tibble. Field description:
#' \itemize{
#' \item seqnames (character) Chromosome name
#' \item start (integer) Substring mapping start position
#' \item end (integer) Substring mapping end position
#' \item readStart_position (integer) Start position of the substring within the read
#' \item readEnd_position (integer) End position of the substring within the read
#' \item width (integer) Width of the substring
#' \item strand (character) Mapping strand (+ or -)
#' \item ligation (character) TARGET-HOST structure of the read as binary code (0 = HOST and 1 = TARGET)
#' \item mapGap (integer) Length of the gap between the end of this mapped substring and the next mapped read substring
#' \item readID (character) ID of the read
#' \item qLength (integer) Total length of the read
#' \item target (logical) TARGET chromosome
#' \item meanGap (integer) Mean of the read mapGap
#' \item sdGap (integer) Standard deviation of the read mapGap
#' \item readSide (character) Describe the position of the substring related to the entire read. Left as first 10% or else right. Used to catch the exact breakpoint.
#' }
#'
#' @keywords PCIP
#'
#' @author Vincent Hahaut
#'
#' @import dplyr
#' @import readr
#' @import purrr
#' @importFrom magrittr %>%
#' @import tibble
#' @import tidyr
#' @import ggplot2
#' @importFrom stats end na.omit sd start
#' @importFrom utils head write.table
#'
#' @note
#' minimap2PAF <- readPairwiseAlignmentFile(minimap2PAF="my/path/to/minimap2.align")
#' PCIP_filter(minimap2PAF = minimap2PAF, targetName="HTLV")
#'
#' @export

PCIP_filter <- function(minimap2PAF = NULL, targetName = NULL){

  suppressPackageStartupMessages(library(tidyverse))

  print(paste0("Initial number of reads : ", length(unique(minimap2PAF$qName))))

  if(!is_empty(minimap2PAF)){

    # 1. Keep primary alignment (tp:A:P)
    print("1. Remove secundary alignments")

    minimap2PAF.primary <- minimap2PAF %>%
      filter(alignmentType == "tp:A:P") %>%
      select(-alignmentType)

    # 2. Filter TARGET-HOST reads

    if(!is.null(targetName)){

      print("2. Remove unwanted target-target and host-host sequences")

      PCIP_filtered <- minimap2PAF.primary %>%
        # 2.1. Add a "lig" field. 1 = TARGET and 0 = HOST.
        mutate(lig = if_else(tName == targetName, 1, 0)) %>%
        group_by(qName) %>%
        # 2.2. Exclude non chimeric reads.
        filter( any(grepl(targetName, tName) ) & !all(tName == targetName)) %>%
        # 2.3. Exclude chimeric reads mapped to several HOST chromosomes.
        filter(length(unique(tName)) < 3) %>%
        arrange(qStart) %>%
        # 2.4. Collapse "lig" information at the read level (10, 01, 101, 1001, ...)
        mutate(ligation = paste0(lig , collapse = "")) %>%
        # 2.5. Add size gap mapping information
        mutate(mapGap = lead(qStart, default = unique(qLength)) - qEnd) %>%
        ungroup() %>%
        mutate(target = tName %in% targetName) %>%
        select(-lig)

      print(paste0("Reads displaying adequat target-genome structure: ", length(unique(PCIP_filtered$qName))))

      print(paste0("Ligation structure Top 10:"))
      print(
        PCIP_filtered %>% select(qName, ligation) %>%
          distinct() %>%
          group_by(ligation) %>%
          summarise(count = n()) %>%
          arrange(desc(count)) %>%
          dplyr::rename("Ligation type (0 = chrom, 1 = target)" = ligation, "Count" = count) %>%
          head(10)
      )

      print("3. Select reads with '01'|'10'|'101'|'1001' structure")

      # 3. Exclude unwanted read structure
      # Add extra formating for GRanges transformation.
      PCIP_filtered <- PCIP_filtered %>%
        mutate(width = tEnd - tStart) %>%
        select(tName, tStart, tEnd, qStart, qEnd, width, orientationToRef, ligation, mapGap, qName, qLength, target) %>%
        arrange(qName) %>%
        dplyr::rename("seqnames" = tName,
                      "start" = tStart,
                      "end" = tEnd,
                      "readStart_position" = qStart,
                      "readEnd_position" = qEnd,
                      "strand" = orientationToRef,
                      "readID" = qName) %>%
        dplyr::filter(ligation %in% c("01","10","101","1001")) %>%
        group_by(readID) %>%
        mutate(meanGap = mean(abs(mapGap)),
               sdGap = sd(abs(mapGap)),
               readSide = if_else(readStart_position < 0.1 * qLength, "left", "right")) %>%
        ungroup()

    } else {

      stop('No Target specified! Please provide one')

    }

  } else{

    warning('Empty or Absent minimap2PAF argument!')

    emptyFile <- tibble(seqnames = character(),
                        start = numeric(),
                        end = numeric(),
                        readStart_position = numeric(),
                        readEnd_position = numeric(),
                        width = numeric(),
                        strand = character(),
                        ligation = character(),
                        mapGap = character(),
                        readID = character(),
                        qLength = character(),
                        target = character())

    PCIP_filtered <- emptyFile

  }

  print(paste0("Reads Post-Filtering: ", length(unique(PCIP_filtered$readID))))
  print(paste0("% Retained : ", 100*round(length(unique(PCIP_filtered$readID))/length(unique(minimap2PAF$qName)),3)))

  return(PCIP_filtered)

}
