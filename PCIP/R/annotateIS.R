#' @title Annotate Integration Sites
#'
#' @description
#' Given a sorted annotation file generated with 'clonality_indexBuilder.sh' (chr, start, end, strand, ensembl_id, gene_name), annotate integration sites.
#' Returns information about the closest features, distances, type of IS (genic or intergenic) and context (concordant or discordant to the nearest up/down features)
#'
#' @param IS data_frame. Integration table generated by \code{"getISposition"}
#' @param geneBedFile.path charachter. Path to the sorted annotation file.
#' @param sample charachter. Name of the sample currently used.
#'
#' @return a tibble, annotated.
#'
#' @author Vincent Hahaut & Nicolas Rosewick
#'
#' @examples
#' LTR3.positions <- getISposition(r1 = r1.LTR3.tidy, r2 = r2.LTR3.tidy, randomTag = randomTag, LTR = "LTR3", recall = FALSE, maxgap = 75)
#' annotateIS(IS = LTR3.positions, geneBedFile = "path/to/geneInfos.sorted.txt", sample = "mySample")
#'
#' @export
annotateIS <- function(IS.path = NULL, gtf.path = NULL, sample = NULL, mode = NULL){

  suppressPackageStartupMessages(library(GenomicRanges))
  suppressPackageStartupMessages(library(tidyverse))
  suppressPackageStartupMessages(library(PCIP))

  # 1. Load GTF
  print("Load GTF")
  if(file.exists(gtf.path)){
    annotation <- parseGTF(gtf.path, prefix = "")
  } else {
    print("No GTF provided !")
    stop()
  }

  if(mode == "breakpoints"){
    print("Load IS")
    IS <- read_tsv(IS.path, col_types = cols(
      seqnames = col_character(),
      edge3.pos = col_integer(),
      edge3.count = col_integer(),
      edge5.pos = col_integer(),
      edge5.count = col_integer(),
      count.max = col_integer(),
      strand = col_character()
      )
    ) %>%
      rowwise() %>%
      mutate(start = min(edge3.pos, edge5.pos, na.rm = T),
             end = max(edge3.pos, edge5.pos, na.rm = T)) %>%
      mutate(orientation = strand,
             strand = "*")

  } else if (mode == "windows"){
    IS <- read_tsv(IS.path) %>%
      select(seqnames, start, end, maxCoverage, numberReads) %>%
      mutate(strand = "*")
  }

  # 2. Load Integration Sites & transform to GRanges:
  IS.gr <- makeGRangesFromDataFrame(IS, keep.extra.columns = T)

  # 3. Split annotation between forward and reverse:
  # This procedure is performed to get overlapping annotation without looking at the orientation (strand column)
  # Feature's orientations are kept into the orientation field
  annotation.gr <- annotation %>%
    makeGRangesFromDataFrame(keep.extra.columns = T, strand.field = "orientation")

  if(length(distanceToNearest(IS.gr, annotation.gr)) > 0){
    print("Intersect annotation/IS")

    # 4. Find overlap geneBed and all IS:
    # Get preceding/following features
    # When inside a gene preceding/following still report the next one while distanceToNearest can report the closest.
    IS_follow <- follow(IS.gr, annotation.gr)
    IS_precede <- precede(IS.gr, annotation.gr)
    IS_nearest <- distanceToNearest(IS.gr, annotation.gr)

    # 5. Get an index table describing the position of the up/down/inside features + distances
    # Get which feature precede/follows each IS (precede = follow when inside a gene)
    # Get the distance to this feature
    annotationIndex.tidy <- bind_cols(following = IS_follow, preceding = IS_precede) %>%
      rownames_to_column("index") %>%
      mutate(index = as.numeric(index)) %>%
      left_join(as_tibble(IS_nearest), by=c("index" = "queryHits")) %>%
      dplyr::rename("nearestFeature" = subjectHits) %>%
      rowwise() %>%
      mutate(index = index,
             following = ifelse(distance == 0, nearestFeature, following),
             preceding = ifelse(distance == 0, nearestFeature, preceding)) %>%
      ungroup() %>%
      # 5.1. Get distance to following-preceding features
      mutate(distanceToFollowing = sapply(seq_along(following), function(x)
        if(!is.na(following[x]))
          distance(IS.gr[index[x]], annotation.gr[following[x]])
        else
          NA)) %>%
      mutate(distanceToPreceding = sapply(seq_along(preceding), function(y)
        if(!is.na(preceding[y]))
          distance(IS.gr[index[y]], annotation.gr[preceding[y]])
        else
          NA))

    # 6. Combine feature information and Integration Sites:
    # Add information from the feature using the generated index
    # Type is genic if distanceToFollowing is == 0
    # Concordance depends on the proviral orientation VS the feature's one
    # IF intergenic, concordance is evaluated on first preceding and then following genes
    IS.annotated <- IS %>%
      rownames_to_column("index") %>%
      mutate(index = as.numeric(index)) %>%
      left_join(annotationIndex.tidy, by=c("index"="index")) %>%
      rowwise() %>%
      mutate(upstream.eid = annotation$eid[following],
             upstream.gene = annotation$gene[following],
             upstream.orientation = annotation$orientation[following],
             upstream.distance = distanceToFollowing,
             downstream.eid = annotation$eid[preceding],
             downstream.gene = annotation$gene[preceding],
             downstream.orientation = annotation$orientation[preceding],
             downstream.distance = distanceToPreceding,
             type = paste0(strand == c(annotation$orientation[preceding], annotation$orientation[following]), collapse=";"),
             context = ifelse(distanceToFollowing == 0, "genic", "intergenic")) %>%
      mutate(type = gsub(x = type, "TRUE", "concordant"),
             type = gsub(x = type, "FALSE", "discordant"),
             type = ifelse(context == "genic", strsplit(type, ";")[[1]][1], type)) %>%
      ungroup() %>%
      mutate(strand = orientation) %>%
      select(-index, -following, -preceding, -nearestFeature, -distance, -distanceToFollowing, -distanceToPreceding, -orientation)

    if(mode == "windows"){
      IS.annotated$type <- "*"
    }

  } else {

    # 7. In case no overlap is found, reports only NA
    IS.annotated <- IS %>%
      bind_cols(upstream.eid = rep(NA, nrow(IS)),
                upstream.gene = rep(NA, nrow(IS)),
                upstream.orientation = rep(NA, nrow(IS)),
                upstream.distance = rep(NA, nrow(IS)),
                downstream.eid = rep(NA, nrow(IS)),
                downstream.gene = rep(NA, nrow(IS)),
                downstream.orientation = rep(NA, nrow(IS)),
                downstream.distance = rep(NA, nrow(IS)),
                type = rep(NA, nrow(IS)),
                context = rep(NA, nrow(IS)),
                sample = rep(sample, nrow(IS)))

  }

  return(IS.annotated)

}
