#' @title Filter Pairwise mApping File produced by Minimap2
#'
#' @description
#' Filter out secundary alignments and select TARGET-HOST chimeric reads.
#' In PAF format each line represents the mapping information of a read substring.
#' Explore the read structure. PCIP-seq reads should contains chimeric viral (1) - host (0) sequences. Only reads matching the following patterns are selected: 101, 01, 10, 1001.
#'
#' @param minimap2PAF tibble. Pairwise mApping file generated by minimap2 and loaded with \code{readPairwiseAlignmentFile}.
#' @param targetName character. Name of the TARGET chromosome.
#'
#' @return PCIP filtered and formated PAF tibble. Field description:
#' \itemize{
#' \item seqnames (character). Chromosome name.
#' \item start (integer). Substring mapping start position.
#' \item end (integer). Substring mapping end position.
#' \item readStart_position (integer). Start position of the substring within the read sequence.
#' \item readEnd_position (integer). End position of the substring within the read sequence.
#' \item width (integer). Width of the substring.
#' \item strand (character). Mapping strand (+ or -).
#' \item ligation (character). TARGET-HOST structure of the read as binary code (0 = HOST and 1 = TARGET).
#' \item mapGap (integer). Length of the gap between the end of this mapped substring and the next mapped read substring.
#' \item readID (character). ID of the read.
#' \item qLength (integer). Total length of the read.
#' \item target (logical). TARGET chromosome.
#' \item meanGap (integer). Alignment gaps are frequent between substrings in nanopore. Reports the mean gap between substrings of a read.
#' \item sdGap (integer). Standard deviation of the inter-substring gaps.
#' }
#'
#' @keywords PCIP
#'
#' @author Vincent Hahaut
#'
#' @import dplyr
#' @import readr
#' @import purrr
#' @importFrom magrittr %>%
#' @import tibble
#' @import tidyr
#' @import ggplot2
#' @importFrom stats end na.omit sd start
#' @importFrom utils head write.table
#'
#' @export

PCIP_filter <- function(minimap2PAF = NULL, targetName = NULL){

  suppressPackageStartupMessages(library(tidyverse))

  print(paste0("Initial number of reads : ", length(unique(minimap2PAF$qName))))

  if(!is_empty(minimap2PAF)){

    # 1. Keep primary alignment (tp:A:P)
    print("1. Remove secundary alignments")

    minimap2PAF.primary <- minimap2PAF %>%
      filter(alignmentType == "tp:A:P") %>%
      select(-alignmentType)

    # 2. Filter TARGET-HOST reads

    if(!is.null(targetName)){

      print("2. Remove unwanted target-target and host-host sequences")

      PCIP_filtered <- minimap2PAF.primary %>%
        # 2.1. Add a "lig" field. 1 = TARGET and 0 = HOST.
        mutate(lig = if_else(tName == targetName, 1, 0)) %>%
        group_by(qName) %>%
        # 2.2. Exclude non chimeric reads.
        filter( any(grepl(targetName, tName) ) & !all(tName == targetName)) %>%
        # 2.3. Exclude chimeric reads mapped to several HOST chromosomes.
        filter(length(unique(tName)) < 3) %>%
        arrange(qStart) %>%
        # 2.4. Collapse "lig" information at the read level (10, 01, 101, 1001, ...)
        mutate(ligation = paste0(lig , collapse = "")) %>%
        # 2.5. Alignment gaps between substrings
        mutate(mapGap = lead(qStart, default = unique(qLength)) - qEnd) %>%
        ungroup() %>%
        mutate(target = tName %in% targetName) %>%
        select(-lig)

      print(paste0("Reads displaying adequat target-genome structure: ", length(unique(PCIP_filtered$qName))))

      print(paste0("Ligation structure Top 10:"))
      print(
        PCIP_filtered %>% select(qName, ligation) %>%
          distinct() %>%
          group_by(ligation) %>%
          summarise(count = n()) %>%
          arrange(desc(count)) %>%
          dplyr::rename("Ligation type (0 = chrom, 1 = target)" = ligation, "Count" = count) %>%
          head(10)
      )

      print("3. Select reads with a '01'|'10'|'101'|'1001' structure")

      # 3. Exclude unwanted read structure
      # Add extra formating for GRanges transformation.
      PCIP_filtered <- PCIP_filtered %>%
        mutate(width = tEnd - tStart) %>%
        select(tName, tStart, tEnd, qStart, qEnd, width, orientationToRef, ligation, mapGap, qName, qLength, target) %>%
        arrange(qName) %>%
        dplyr::rename("seqnames" = tName,
                      "start" = tStart,
                      "end" = tEnd,
                      "readStart_position" = qStart,
                      "readEnd_position" = qEnd,
                      "strand" = orientationToRef,
                      "readID" = qName) %>%
        dplyr::filter(ligation %in% c("01","10","101","1001")) %>%
        # Compute the mean and sd gap between substrings.
        group_by(readID) %>%
        mutate(meanGap = mean(abs(mapGap)),
               sdGap = sd(abs(mapGap))) %>%
        ungroup()

    } else {

      stop('No Target specified! Please provide one')

    }

  } else{

    warning('Empty or Absent minimap2PAF argument!')

    emptyFile <- tibble(seqnames = character(),
                        start = numeric(),
                        end = numeric(),
                        readStart_position = numeric(),
                        readEnd_position = numeric(),
                        width = numeric(),
                        strand = character(),
                        ligation = character(),
                        mapGap = character(),
                        readID = character(),
                        qLength = character(),
                        target = character())

    PCIP_filtered <- emptyFile

  }

  print(paste0("Reads Post-Filtering: ", length(unique(PCIP_filtered$readID))))
  print(paste0("% Retained : ", 100*round(length(unique(PCIP_filtered$readID))/length(unique(minimap2PAF$qName)),3)))

  return(PCIP_filtered)

}
